"use strict";
/*jshint newcap: false*/
/*global Q: true, describe: false, it: false, expect: false, beforeEach: false,
         afterEach: false, require: false, jasmine: false, waitsFor: false,
         runs: false */

if (typeof Q === "undefined" && typeof require !== "undefined") {
    // For Node compatibility.
    global.Q = require("../q");
    require("./lib/jasmine-promise");
}

var REASON = "this is not an error, but it might show up in the console";

// In browsers that support strict mode, it'll be `undefined`; otherwise, the global.
var calledAsFunctionThis = (function () { return this; }());

afterEach(function () {
    Q.onerror = null;
});

describe("computing sum of integers using promises", function() {
    it("should compute correct result without blowing stack", function () {
        var array = [];
        var iters = 1000;
        for (var i = 1; i <= iters; i++) {
            array.push(i);
        }

        var pZero = Q.resolve(0);
        var result = array.reduce(function (promise, nextVal) {
            return promise.then(function (currentVal) {
                return Q.resolve(currentVal + nextVal);
            });
        }, pZero);

        return result.then(function (value) {
            expect(value).toEqual(iters * (iters + 1) / 2);
        });
    });
});

describe("Q function", function () {

    it("should be the identity when given promise", function () {
        var f = Q.resolve(5);
        var r = Q.reject(new Error("aaargh"));
        var p = Q.promise(function () { });

        expect(Q(f)).toBe(f);
        expect(Q(r)).toBe(r);
        expect(Q(p)).toBe(p);
    });
});

describe("defer and then", function () {

    it("resolve before then", function () {
        var turn = 0;
        var deferred = Q.defer();
        deferred.resolve(10);
        var promise = deferred.promise.then(function (value) {
            expect(turn).toEqual(1);
            expect(value).toEqual(10);
        });
        turn++;
        return promise;
    });

    it("reject before then", function () {
        var turn = 0;
        var deferred = Q.defer();
        deferred.reject(-1);
        var promise = deferred.promise.then(function () {
            expect(true).toBe(false);
        }, function (value) {
            expect(turn).toEqual(1);
            expect(value).toEqual(-1);
        });
        turn++;
        return promise;
    });

    it("resolves multiple observers", function (done) {
        var nextTurn = false;

        var resolution = "Taram pam param!";
        var deferred = Q.defer();
        var count = 10;
        var i = 0;

        function resolve(value) {
            i++;
            expect(value).toBe(resolution);
            expect(nextTurn).toBe(true);
            if (i === count) {
                done();
            }
        }

        while (++i <= count) {
            deferred.promise.then(function(value) {resolve(value)});
        }

        deferred.resolve(resolution);
        i = 0;
        nextTurn = true;
    });

    it("observers called even after throw", function () {
        var threw = false;
        var deferred = Q.defer();
        deferred.promise.then(function () {
            threw = true;
            throw new Error(REASON);
        });
        var promise = deferred.promise.then(function (value) {
            expect(value).toEqual(10);
        }, function () {
            expect("not").toEqual("here");
        });
        deferred.resolve(10);
        return promise;
    });

    it("returns `undefined` from the deferred's methods", function () {
        expect(Q.defer().resolve()).toBe(undefined);
        expect(Q.defer().reject()).toBe(undefined);
    });

});

describe("always next tick", function () {

    it("generated by `resolve`", function () {
        var turn = 0;
        var promise = Q().then(function () {
            expect(turn).toEqual(1);
        });
        turn++;
        return promise;
    });

    it("generated by `reject`", function () {
        var turn = 0;
        var promise = Q.reject().then(function () {
            expect(true).toBe(false);
        }, function () {
            expect(turn).toEqual(1);
        });
        turn++;
        return promise;
    });
});

describe("propagation", function () {

    it("propagate through then with no callback", function () {
        return Q(10)
        .then()
        .then(function (ten) {
            expect(ten).toBe(10);
        });
    });

    it("propagate through then with modifying callback", function () {
        return Q(10)
        .then(function (ten) {
            return ten + 10;
        })
        .then(function (twen) {
            expect(twen).toBe(20);
        });
    });

    it("errback recovers from exception", function () {
        var error = new Error("Bah!");
        return Q.reject(error)
        .then(null, function (_error) {
            expect(_error).toBe(error);
            return 10;
        })
        .then(function (value) {
            expect(value).toBe(10);
        });
    });

    it("rejection propagates through then with no errback", function () {
        var error = new Error("Foolish mortals!");
        return Q.reject(error)
        .then()
        .then(null, function (_error) {
            expect(_error).toBe(error);
        });
    });

    it("rejection intercepted and rethrown", function () {
        var error = new Error("Foolish mortals!");
        var nextError = new Error("Silly humans!");
        return Q.reject(error)
        .fail(function () {
            throw nextError;
        })
        .then(null, function (_error) {
            expect(_error).toBe(nextError);
        });
    });

    it("resolution is forwarded through deferred promise", function () {
        var a = Q.defer();
        var b = Q.defer();
        a.resolve(b.promise);
        b.resolve(10);
        return a.promise.then(function (eh) {
            expect(eh).toEqual(10);
        });
    });
});

describe("all", function () {
    it("fulfills when passed an empty array", function () {
        return Q.all([]);
    });

    it("rejects after any constituent promise is rejected", function () {
        var toResolve = Q.defer(); // never resolve
        var toReject = Q.defer();
        var promises = [toResolve.promise, toReject.promise];
        var promise = Q.all(promises);

        toReject.reject(new Error("Rejected"));

        promise.then(function () {
            expect(true).toBe(false);
        }, function(err){
            expect(err.message).toBe("Rejected")
        })
    });

    it("resolves foreign thenables", function () {
        var normal = Q(1);
        var foreign = { then: function (f) { f(2); } };

        return Q.all([normal, foreign])
        .then(function (result) {
            expect(result).toEqual([1, 2]);
        });
    });

    it("fulfills when passed an sparse array", function () {
        var toResolve = Q.defer();
        var promises = [];
        promises[0] = Q(0);
        promises[2] = toResolve.promise;
        var promise = Q.all(promises);

        toResolve.resolve(2);

        return promise.then(function (result) {
            expect(result).toEqual([0, void 0, 2]);
        });
    });

});

describe("any", function() {

    it("rejects after all promises are rejected", function() {
        var deferreds = [Q.defer(), Q.defer()];
        var promises = [deferreds[0].promise, deferreds[1].promise];

        return testReject(promises, deferreds, new Error("Rejected"));
    });

    it("rejects after all promises in a sparse array are rejected", function() {
        var deferreds = [Q.defer(), Q.defer()];
        var promises = [];
        promises[0] = deferreds[0].promise;
        promises[3] = deferreds[1].promise;

        return testReject(promises, deferreds, new Error("Rejected"));
    });


    it("rejects after all promises are rejected with null", function() {
        var deferreds = [Q.defer(), Q.defer()];
        var promises = [deferreds[0].promise, deferreds[1].promise];

        return testReject(promises, deferreds, null);
    });

    it("rejects after all promises are rejected with undefined", function() {
        var deferreds = [Q.defer(), Q.defer()];
        var promises = [deferreds[0].promise, deferreds[1].promise];

        return testReject(promises, deferreds, undefined);
    });

    function testReject(promises, deferreds, rejectionValue) {
        var promise = Q.any(promises);
        var expectedError;

        if (rejectionValue) {
          expectedError = new Error(rejectionValue.message);
        } else {
          expectedError = new Error("" + rejectionValue);
        }

        for (var index = 0; index < deferreds.length; index++) {
            var deferred = deferreds[index];
            (function() {
              deferred.reject(rejectionValue);
            })();
        }

        promise.then(function () {
            expect(true).toBe(false);
        }, function(err){
            expect(err.message).toBe(rejectionValue)
        })
    }

    it("fulfills with the first resolved promise", function() {
        var deferreds = [Q.defer(), Q.defer()];
        var promises = [deferreds[0].promise, deferreds[1].promise];

        testFulfill(promises, deferreds);
    });

    it("fulfills when passed a sparse array", function() {
        var deferreds = [Q.defer(), Q.defer()];
        var promises = [];
        promises[0] = deferreds[0].promise;
        promises[2] = deferreds[1].promise;

        testFulfill(promises, deferreds);
    });

    function testFulfill(promises, deferreds) {
        var promise = Q.any(promises);

        var j = 1;
        for (var index = 0; index < deferreds.length; index++) {
            var toResolve = deferreds[index];

            (function(index, toResolve) {
                var time = index * 50;
                Q.delay(time).then(function() {
                    toResolve.resolve('Fulfilled' + index);
                });
            })(j, toResolve);

            j++;
        }

        return promise.then(function (value) {
            expect(value).toBe('Fulfilled1');
        }, function(err){
            expect(false).toBe(true)
        })
    }

    it("fulfills with the first value", function() {
        var toResolve1 = Q.defer();
        var toResolve2 = Q.defer();
        var toResolve3 = Q.defer();
        var promises = [toResolve1.promise, toResolve2.promise, 4, 5,
            toResolve3.promise
        ];

        var promise = Q.any(promises);

        Q.delay(150).then(function() {
            toResolve1.resolve(1);
        });
        Q.delay(50).then(function() {
            toResolve2.resolve(2);
        });
        Q.delay(100).then(function() {
            toResolve3.resolve(3);
        });

        promise
          .then(function(value) {
              expect(value).toBe(4);
          })
          .timeout(1000);
    });

    it("fulfills after rejections", function() {
        var toReject = [Q.defer(), Q.defer()];
        var toResolve = Q.defer();
        var promises = [toReject[0].promise, toReject[1].promise,
            toResolve
            .promise
        ];

        var promise = Q.any(promises);

        testFulfillAfterRejections(promises, toReject, toResolve);
    });

    it("fulfills after rejections in sparse array", function() {
        var toReject = [Q.defer(), Q.defer()];
        var toResolve = Q.defer();
        var promises = [];
        promises[2] = toReject[0].promise;
        promises[5] = toReject[1].promise;
        promises[9] = toResolve.promise;

        testFulfillAfterRejections(promises, toReject, toResolve);
    });

    function testFulfillAfterRejections(promises, rejectDeferreds,
      fulfillDeferred) {
        var promise = Q.any(promises);

        for (var index = 0; index < rejectDeferreds.length; index++) {
            var toReject = rejectDeferreds[index];
            (function(index, toReject) {
                var time = (index + 1) * 50;
                Q.delay(time).then(function() {
                    toReject.reject(new Error('Rejected'));
                });
            })(index, toReject);

            index++;
        }
        Q.delay(index * 50).then(function() {
            fulfillDeferred.resolve('Fulfilled');
        });

        return Q.delay(400)
          .then(function() {
              expect(promise.isFulfilled()).toBe(true);
              expect(promise.inspect().value).toBe('Fulfilled');
          })
          .timeout(1000);
    }
});

describe("allSettled", function () {

    it("deals with a mix of non-promises and promises", function () {
        Q.allSettled([1, Q(2), Q.reject(3)])
        .then(function (snapshots) {
            expect(snapshots).toEqual([
                { status: "fulfilled", value: 1 },
                { status: "fulfilled", value: 2 },
                { status: "rejected", reason: 3 }
            ]);
        });
    });

    it("is settled after every constituent promise is settled", function () {
        var toFulfill = Q.defer();
        var toReject = Q.defer();
        var promises = [toFulfill.promise, toReject.promise];
        var fulfilled;
        var rejected;

        Q.delay(10).then(function () {
            toReject.reject();
            rejected = true;
        })
        Q.delay(15)
        .then(function () {
            toFulfill.resolve();
            fulfilled = true;
        });

        Q.allSettled(promises)
        .then(function () {
            expect(fulfilled).toBe(true);
            expect(rejected).toBe(true);
        });
    });

    it("does not modify the input array", function () {
        var input = [1, Q(2), Q.reject(3)];

        Q.allSettled(input)
        .then(function (snapshots) {
            expect(snapshots).not.toBe(input);
            expect(snapshots).toEqual([
                { status: "fulfilled", value: 1 },
                { status: "fulfilled", value: 2 },
                { status: "rejected", reason: 3 }
            ]);
        });
    });

});

describe("timeout", function () {

    it("should do nothing if the promise rejects quickly", function () {
        var goodError = new Error("haha!");
        Q.delay(10)
        .then(function () {
            throw goodError;
        })
        .timeout(200)
        .then(undefined, function (error) {
            expect(error).toBe(goodError);
        });
    });

    it("should reject with a timeout error if the promise is too slow", function () {
        Q.delay(100)
        .timeout(10)
        .then(
            function () {
                expect(true).toBe(false);
            },
            function (error) {
                expect(/time/i.test(error.message)).toBe(true);
            }
        );
    });

    it("should reject with a custom timeout error if the promise is too slow and msg was provided", function () {
        Q.delay(100)
        .timeout(10, "custom")
        .then(
            function () {
                expect(true).toBe(false);
            },
            function (error) {
                expect(/custom/i.test(error.message)).toBe(true);
                expect(error.code).toBe("ETIMEDOUT");
            }
        );
    });

});

describe("delay", function () {
    it("should delay fulfillment", function () {
        var resolved = 0;
        Q(5).delay(50).then((value)=>{
            resolved = value;
        })

        setTimeout(function () {
            expect(resolved).toBe(0);
        }, 40);

        setTimeout(function () {
            expect(resolved).toBe(5);
        }, 60);
    });

    it("should not delay rejection", function () {
        var rejected = 0;
        Q.reject(5).delay(50).then((value)=>{
            rejected = value;
        })

        setTimeout(function () {
            expect(rejected).toBe(5);
        }, 10);
    });
});

describe("browser support", function () {
    var _Q;

    beforeEach(function() {
        _Q = Q;
    });

    afterEach(function() {
        Q = _Q;
    });

    it("sets the global Q object to its original value", function() {
        if (typeof window !== 'undefined') {
            // If window is not undefined, the tests are running in the browser
            // assert that Q.noConflict returns window.Q to it's initial value
            // In this context the original value of Q is undefined
            Q.noConflict();
            expect(Q).toEqual(undefined);
        }
    });

    it("throws an error if Q.noConflict is called in node", function () {
        if (typeof window === 'undefined') {
            // If window is undefined the tests are being run in node, and
            // Q.noConflict should throw an error
            expect(Q.noConflict).toThrow();
        }
    });
});

if (typeof require === "function") {
    var domain;
    try {
        domain = require("domain");
    } catch (e) { }

    if (domain) {
        var EventEmitter = require("events").EventEmitter;

        describe("node domain support", function () {
            var d;

            beforeEach(function () {
                d = domain.create();
            });

            it("should work for non-promise async inside a promise handler",
               function (done) {
                var error = new Error("should be caught by the domain");

                d.run(function () {
                    Q().then(function () {
                        setTimeout(function () {
                            throw error;
                        }, 10);
                    });
                });

                var errorTimeout = setTimeout(function () {
                    done(new Error("Wasn't caught"));
                }, 100);

                d.on("error", function (theError) {
                    expect(theError).toBe(error);
                    clearTimeout(errorTimeout);
                    done();
                });
            });

            it("should transfer errors from `done` into the domain",
               function (done) {
                var error = new Error("should be caught by the domain");

                d.run(function () {
                    Q.reject(error).done();
                });

                var errorTimeout = setTimeout(function () {
                    done(new Error("Wasn't caught"));
                }, 100);

                d.on("error", function (theError) {
                    expect(theError).toBe(error);
                    clearTimeout(errorTimeout);
                    done();
                });
            });

            it("should take care of re-used event emitters", function (done) {
                // See discussion in https://github.com/kriskowal/q/issues/120
                var error = new Error("should be caught by the domain");

                var e = new EventEmitter();

                d.run(function () {
                    callAsync().done();
                });
                setTimeout(function () {
                    e.emit("beep");
                }, 100);

                var errorTimeout = setTimeout(function () {
                    done(new Error("Wasn't caught"));
                }, 500);

                d.on("error", function (theError) {
                    expect(theError).toBe(error);
                    clearTimeout(errorTimeout);
                    done();
                });

                function callAsync() {
                    var def = Q.defer();
                    e.once("beep", function () {
                        def.reject(error);
                    });
                    return def.promise;
                }
            });
        });
    }
}